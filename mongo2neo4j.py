"""
##
# mongo2neo4j
#
# Imports objects structures generated by the ORM mongoose <https://mongoosejs.com/> and 
# stored in MongoDB <https://www.mongodb.com/> into Neo4j <https://neo4j.com/> for exploration with 
# SemSpect <https://www.semspect.de/>
#
# Author: Marko Luther
"""

import traceback
from collections.abc import MutableMapping
from typing import Optional, Dict, List, Tuple, Any, Callable, TYPE_CHECKING

from pymongo import MongoClient
from bson.objectid import ObjectId
from neo4j import GraphDatabase

if TYPE_CHECKING:
    from pymongo.database import Database
    from pymongo.cursor import Cursor


# Configuration

mongoDB_host:str = "localhost"
mongoDB_port:int = 21121
mongoDB_DB:str = "ArtisanPlus"
neo4j_host:str = "localhost"
neo4j_port:int = 7687
neo4j_user:str = "neo4j"
neo4j_password:str = "splash_2"
neo4j_database:Optional[str] = None
output_cypher:bool = True
send_to_neo4j:bool = True
attr_to_remove:List[str] = [
    '__v'
]
# DB specific attributes to be removed
additional_attr_to_remove:List[str] = [
    'hash', # sensitive
    'password_reset_token', # sensitive
    'updated_by', # mostly the same as created_by
    'image' # not accessible 
]


# Utility functions

def apply_recursive(func:Callable[[Any], Any], obj:Any) -> Any:
    """Applies the given function recursively to all elements of the give object."""
    if isinstance(obj, dict):  # if dict, apply to each key
        return {k: apply_recursive(func, v) for k, v in obj.items()}
    elif isinstance(obj, list):  # if list, apply to each element
        return [apply_recursive(func, elem) for elem in obj]
    else:
        return func(obj)

def flatten_and_cleanse(dictionary:MutableMapping[str, Any], parent_key:str = '', separator:str = '_', suppress:List[str] = []) -> Dict[str, Any]:
    """Returns the given dictionary with sub dictionaries flattend and keys in in the suppress list removed."""
    res:Dict[str, Any] = {}
    for key, value in dictionary.items():
        if key not in suppress and value is not None and value != '' and value != []:
            new_key = parent_key + separator + key if parent_key else key
            if isinstance(value, MutableMapping):
                res.update(flatten_and_cleanse(value, new_key, separator=separator))
            else:
                res[new_key] = value
    return res


# MongoDB communication

def get_database() -> 'Database':
    client:MongoClient = MongoClient(mongoDB_host, mongoDB_port)
    return client[mongoDB_DB]


# Neo4j communication

def output_query(query, **kwargs) -> None:
    """Outputs the given Cypher query to stdout."""
    result = query
    for key, value in kwargs.items():
        result = result.replace(f'${key}', str(value))
    print(result)

def run_query(driver, query, **kwargs) -> None:
    """Sends the given query to Neo4j and outputs it to stdout if output_cyhper is True."""
    if output_cypher:
        output_query(query, **kwargs)
    if send_to_neo4j:
        driver.execute_query(
                query,
                database_=neo4j_database,
                **kwargs)

def merge_node(driver, label:str, d:Dict[str, Any]) -> None:
    """ ."""
    attribs = ""
    relations = {}
    if '_id' in d:
        id = str(d['_id']) # ObjectId to sting
        for key in d.keys():
            if key == '_id':
                d[key] = id
            elif isinstance(d[key], ObjectId):
                # other attributes with values of type ObjectId are turned into relations
                relations[key] = d[key]
            attrib = f"{key}: ${key}"
            attribs = (attrib if attribs == "" else f"{attribs}, {attrib}")
        # replace all ObjectId instances by their string representation recursively
        d = apply_recursive(lambda x : (str(x) if isinstance(x, ObjectId) else x), d)
        query = f"MERGE (:{label} {{{attribs}}})"
        for key,value in d.items():
            print(key,type(value),value)
        run_query(driver, query, **d)
        # add relations
        for key in relations.keys():
            other_object_id = str(relations[key])
            query = f"MATCH (a:{label}), (b) WHERE a._id = '{str(id)}' and b._id = '{other_object_id}' MERGE (a)-[:{key}]->(b)"
            run_query(driver, query)

# split given dict in the part containing only primitive values (or lists thereof) and a dict with all non_primitive values
def split_attributes(d:Dict[str, Any]) -> Tuple[Dict[str, Any], Dict[str, Any]]:
    primitive:Dict[str, Any] = {}
    non_primitive:Dict[str, Any] = {}
    for key, value in d.items():
        if isinstance(value, list) and not all(isinstance(e, (int, float, bool, str)) for e in value):
            non_primitive[key] = value
        else:
            primitive[key] = value
    return primitive, non_primitive

def to_neo4j(table:str, data:List[Dict[str,Any]]) -> None:
    label:str = table.capitalize()
    neo4j_uri:str = f'neo4j://{neo4j_host}:{neo4j_port}'
    # connect
    with GraphDatabase.driver(neo4j_uri, auth=(neo4j_user, neo4j_password)) as driver:
        try:
            # 1. establish constraints on labels
            # the use of $ query parameters for constraint name and label does not work here so we use Python fstring substitution
            run_query(driver, f"CREATE CONSTRAINT {label.lower()}_cstr IF NOT EXISTS FOR (l:{label}) REQUIRE l._id IS UNIQUE")
            
            # 2. add nodes and relations
            for d in data:
                primitive, _non_primitive = split_attributes(d)
                merge_node(driver, label, primitive)
        except Exception:
            traceback.print_exc()


if __name__ == "__main__":
    db:'Database' = get_database()
    collections:List[str] = db.list_collection_names()
    collection:str
    for collection in collections:
        data:'Cursor[Any]' = db[collection].find()
        # remove attributes we are not interested in and flatten dicts
        d:Dict[str, Any]
        data_cleansed:List[Dict[str, Any]] = [flatten_and_cleanse(d, suppress=attr_to_remove+additional_attr_to_remove) for d in data]
        # send to Neo4j
        to_neo4j(collection, data_cleansed)
