#!/usr/bin/env python3
"""
##
# mongo2neo4j
#
# Imports objects structures generated by the ORM mongoose <https://mongoosejs.com/> and
# stored in MongoDB <https://www.mongodb.com/> into Neo4j <https://neo4j.com/> for exploration with
# SemSpect <https://www.semspect.de/>
#
# Author: Marko Luther
"""

import timeit
import argparse
import datetime
from collections.abc import MutableMapping, Callable
from typing import Any, TYPE_CHECKING

from pymongo import MongoClient
from bson.objectid import ObjectId
from neo4j import GraphDatabase, Driver, Session
from neo4j.time import DateTime

if TYPE_CHECKING:
    from pymongo.database import Database
    from pymongo.cursor import Cursor


# Globals

attr_to_remove: list[str] = [
    '__v'  # the document version will always be ignored and never transferred
]


# Utility functions


def apply_recursive(func: Callable[[Any], Any], obj: Any) -> Any:
    """Applies the given function recursively to all elements of the give object."""
    if isinstance(obj, dict):  # if dict, apply to each key
        return {k: apply_recursive(func, v) for k, v in obj.items()}
    if isinstance(obj, list):  # if list, apply to each element
        return [apply_recursive(func, elem) for elem in obj]
    return func(obj)


def flatten_and_cleanse(
    dictionary: MutableMapping[str, Any],
    parent_key: str = '',
    separator: str = '_',
    suppress: None | list[str] = None,
) -> dict[str, Any]:
    """Returns the given dictionary with sub dictionaries flattend and \
        keys in in the suppress list removed."""
    if suppress is None:
        suppress = []
    res: dict[str, Any] = {}
    for key, value in dictionary.items():
        if key not in suppress and value is not None and value != '' and value != []:
            new_key = parent_key + separator + key if parent_key else key
            if isinstance(value, MutableMapping):
                res.update(flatten_and_cleanse(value, new_key, separator=separator))
            else:
                res[new_key] = value
    return res


# Neo4j communication


def neo4j_output_query(query, **kwargs) -> None:
    """Outputs the given Cypher query to stdout."""
    result = query
    for key, value in kwargs.items():
        result = result.replace(
            f'${key}',
            (
                f'datetime({value})'
                if isinstance(value, (datetime.datetime|DateTime))
                else str(value)
            ),
        )
    print(result)


def neo4j_run_write_query(
    session: None|Session, verbose: bool, query, **kwargs
) -> None:
    """Sends the given query to Neo4j and outputs it to stdout if output_cyhper is True."""

    def work(tx): # pylint: disable=invalid-name
        return tx.run(query, **kwargs)
    if verbose:
        neo4j_output_query(query, **kwargs)
    if session is not None:
        session.execute_write(work)


def merge_node(
    session: None|Session,
    label: str,
    document: dict[str, Any],
    verbose: bool,
) -> None:
    """Merges <label> node defined by <document> and links it to other nodes \
        as specified by its ObjectId values"""
    attribs:str = ''
    relations:dict[str, Any] = {}
    if '_id' in document:
        node_id = str(document['_id'])  # ObjectId to string
        for key in document:
            if key == '_id':
                document[key] = node_id
            elif isinstance(document[key], ObjectId):
                # other attributes with values of type ObjectId are turned into relations
                relations[key] = document[key]
            attrib = f'{key}: ${key}'
            attribs = attrib if attribs == '' else f'{attribs}, {attrib}'
        # replace all ObjectId instances by their string representation recursively
        document = apply_recursive(
            lambda x: (str(x) if isinstance(x, ObjectId) else x), document
        )
        query = f'MERGE (:{label} {{{attribs}}})'
        neo4j_run_write_query(session, verbose, query, **document)
        # add relations
        for key, value in relations.items():
            other_object_id = str(value)
            query = (f"MATCH (a:{label}), (b) WHERE a._id = '{node_id}' and "
                f"b._id = '{other_object_id}' MERGE (a)-[:{key}]->(b)")
            neo4j_run_write_query(session, verbose, query)


def split_attributes(
    dictionary: dict[str, Any]
) -> tuple[dict[str, Any], dict[str, Any]]:
    """Splits the given attributes into those with primitive values and those with \
        non-primitive ones"""
    primitive: dict[str, Any] = {}
    non_primitive: dict[str, Any] = {}
    for key, value in dictionary.items():
        if isinstance(value, list) and not all(
            isinstance(e, (str|bool|int|float)) for e in value
        ):
            non_primitive[key] = value
        else:
            primitive[key] = value
    return primitive, non_primitive

# pylint: disable=too-many-arguments
def process_data(
    database: Database,
    session: None|Session,
    collections: set[str],
    excluded_collections: list[str],
    excluded_fields: list[str],
    verbose: bool,
) -> None:
    """Transfers all <collections> of the given MongoDB <db> via the <session> to Neo4j's \
        <neo4j_db> DB excluding the <excluded_collections> and the <excluded_fields>.
    If verbose, the generated Cypher queries are printed to stdout."""
    for collection in collections:
        if collection not in excluded_collections:
            print(f"*** processing collection '{collection}'")
            # Establish constraints on labels
            # NOTE: the use of $ query parameters for constraint name and label
            #       does not work here so we use Python fstring substitution
            neo4j_run_write_query(
                session,
                verbose,
                (f'CREATE CONSTRAINT {collection}_cstr IF NOT EXISTS FOR (l:{collection}) '
                  'REQUIRE l._id IS UNIQUE'),
            )
            data: Cursor[Any] = database[collection].find()
            # remove attributes we are not interested in and flatten dicts
            attribs: dict[str, Any]
            for attribs in data:
                # cleans data
                cleansed_data: dict[str, Any] = flatten_and_cleanse(
                    attribs, suppress=attr_to_remove + excluded_fields
                )
                # send to Neo4j
                # 2. add node and relations to Neo4j
                primitive, _non_primitive = split_attributes(cleansed_data)
                merge_node(session, collection, primitive, verbose)


# pylint: disable=too-many-locals
def main(
    mongo_host: str,
    mongo_port: int,
    mongo_db: str,
    neo4j_host: str,
    neo4j_port: int,
    neo4j_user: str,
    neo4j_password: str,
    neo4j_db: str,
    excluded_collections: list[str],
    included_collections: None|list[str],
    excluded_fields: list[str],
    verbose: bool = False,
    simulate: bool = False,
) -> None:
    """The main mongo2neo4j function that takes MongoDB credential and DB name, Neo4j credentials \
        and DB name and a sepecification which MongoDB collections and attributes should be \
        transferred to Neo4j, if the Cypher queries should be printed to stdout (verbose=True) \
        and if the Neo4j engine should be connected to or not (simulate=True)."""

    # connect to MongDB
    mongo_client: MongoClient = MongoClient(mongo_host, mongo_port)
    # get MongoDB DB
    database: Database = mongo_client[mongo_db]

    db_collections: list[str] = database.list_collection_names()
    collections: set[str] = (
        set(db_collections)
        if included_collections is None
        else set(included_collections).intersection(db_collections)
    )

    if simulate:
        process_data(
            database,
            None,
            collections,
            excluded_collections,
            excluded_fields,
            verbose,
        )
    else:
        driver: Driver
        with GraphDatabase.driver( # pylint: disable=not-context-manager
            f'neo4j://{neo4j_host}:{neo4j_port}', auth=(neo4j_user, neo4j_password)
        ) as driver:
            session: Session
            with driver.session(database=neo4j_db) as session:
                process_data(
                    database,
                    session,
                    collections,
                    excluded_collections,
                    excluded_fields,
                    verbose,
                )


if __name__ == '__main__':
    arg_desc:str = (
        'mongo2neo4j -- Imports objects structures generated by the ORM mongoose and '
        'stored in MongoDB into Neo4j for exploration with SemSpect'
    )
    parser = argparse.ArgumentParser(description=arg_desc)
    parser.add_argument('-v', '--verbose', action='store_true', help='Output Cyhper')
    parser.add_argument(
        '-s', '--simulate', action='store_true', help="Don't connect to Neo4j"
    )
    parser.add_argument(
        '-mh',
        '--mongo_host',
        dest='mongo_host',
        type=str,
        default='localhost',
        help='MongoDB hostname',
    )
    parser.add_argument(
        '-mp',
        '--mongo_port',
        dest='mongo_port',
        type=int,
        default='27017',
        help='MongoDB port',
    )
    parser.add_argument(
        '-nh',
        '--neo4j_host',
        dest='neo4j_host',
        type=str,
        default='localhost',
        help='Neo4j hostname',
    )
    parser.add_argument(
        '-np',
        '--neo4j_port',
        dest='neo4j_port',
        type=int,
        default='7687',
        help='Neo4j port',
    )
    parser.add_argument(
        '-nu',
        '--neo4j_user',
        dest='neo4j_user',
        type=str,
        default='neo4j',
        help='Neo4j user',
    )
    parser.add_argument(
        '-npw',
        '--neo4j_password',
        dest='neo4j_password',
        type=str,
        required=True,
        help='Neo4j password',
    )
    parser.add_argument(
        '-nd', '--neo4j_db', dest='neo4j_db', type=str, help='Neo4j DB to import into'
    )
    parser.add_argument(
        '-i',
        '--include',
        dest='included_collections',
        action='append',
        help='Collection to be transferred. If not specified, transfer all not excluded ones.',
    )
    parser.add_argument(
        '-x',
        '--exclude',
        dest='excluded_collections',
        action='append',
        default=[],
        help='Collection to be excluded',
    )
    parser.add_argument(
        '-f',
        '--exclude_fields',
        dest='excluded_fields',
        action='append',
        default=[],
        help='MongoDB document fields to be ignored',
    )

    parser.add_argument('mongo_db', help='MongoDB DB to import from')
    args = parser.parse_args()
    requested_collections: None|list[str] = None
    if args.included_collections is not None:
        requested_collections = []
        for c in args.included_collections:
            for s in c.split(','):
                requested_collections.append(s)
    args_excluded_collections:list[str] = []
    for c in args.excluded_collections:
        for s in c.split(','):
            args_excluded_collections.append(s)
    args_excluded_fields:list[str] = []
    if args.excluded_fields is not None:
        for fields in args.excluded_fields:
            for f in fields.split(','):
                args_excluded_fields.append(f)

    print(timeit.timeit(number=1, stmt=lambda:
        main(
            args.mongo_host,
            args.mongo_port,
            args.mongo_db,
            args.neo4j_host,
            args.neo4j_port,
            args.neo4j_user,
            args.neo4j_password,
            args.neo4j_db,
            args_excluded_collections,
            requested_collections,
            args_excluded_fields,
            args.verbose,
            args.simulate,
        )))
